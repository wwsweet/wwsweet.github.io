{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"sweet","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"文件IO","slug":"文件IO","date":"2017-07-15T06:32:23.000Z","updated":"2017-07-15T06:55:09.439Z","comments":true,"path":"2017/07/15/文件IO/","link":"","permalink":"http://yoursite.com/2017/07/15/文件IO/","excerpt":"文本文件：打开文件：","text":"文本文件：打开文件：123f = open('D:/sss.txt', 'r')print(f.read())f.close() 用with语句打开文件：12with open('D:/sss.txt', 'r') as f: print(f.read()) 要读取非UTF-8编码的文本文件，需要给 open() 函数传入 encoding 参数例如，读取 GBK 编码的文件：12f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')print(f.read()) 二进制文件（图片视频）：读文件：12f = open('/Users/michael/test.jpg', 'rb')print(f.read()) 写文件：12with open('/Users/michael/test.txt', 'w') as f: f.write('Hello, world!') StringIO和BytesIOStringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO 读取StringIO ：1234567891011from io import StringIOf = StringIO('Hello!\\nHi!\\nGoodbye!')while True: s = f.readline() if s == '': break print(s.strip())输出结果：Hello!Hi!Goodbye! 写文件：123456789101112from io import StringIOf = StringIO()print(f.write('hello'))print(f.write(' '))print(f.write('world!'))print(f.getvalue())输出：516hello world! BytesIO12345678from io import BytesIOf = BytesIO()print(f.write('中文'.encode('utf-8')))print(f.getvalue())输出：6b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 操作文件和目录：os模块12import osprint(os.name) #操作类型 1.获取详细的系统信息，可以调用 uname() 函数：print(os.uname()) 2.操作系统中定义的环境变量，全部保存在 os.environ 这个变量中，可以直接查看：print(os.environ) 3.要获取某个环境变量的值，可以调用print(os.environ.get(&#39;PATH&#39;)) 4.查看当前目录的绝对路径:print( os.path.abspath(&#39;.&#39;)) 5.把一个路径拆分为两部分，后一部分总 是最后级别的目录或文件名：print( os.path.split(&#39;/Users/michael/testdir/file.txt&#39;)) 6.直接得到文件扩展名print(os.path.splitext(&#39;/path/to/file.txt&#39;)) 7.对文件重命名:os.rename(&#39;test.txt&#39;, &#39;test.py&#39;) 8.删掉文件: os.remove(&#39;test.py&#39;) 9.要列出当前目 录下的所有目录:[x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)] 10.要列出所有的 .py 文件:[x for x in os.listdir(&#39;.&#39;) if os.path.isfile(x) and os.path.splitext(x)[1]==&#39;.py&#39;]","categories":[],"tags":[]},{"title":"端口扫描","slug":"端口扫描","date":"2017-07-13T06:42:04.000Z","updated":"2017-07-13T06:59:51.271Z","comments":true,"path":"2017/07/13/端口扫描/","link":"","permalink":"http://yoursite.com/2017/07/13/端口扫描/","excerpt":"简单的端口扫描器代码：","text":"简单的端口扫描器代码： 123456789101112131415161718192021222324#!/usr/bin/env python# -*- coding: utf-8 -*-import sysfrom socket import *host = sys.argv[1] #读取端口及目标服务器ports = sys.argv[2].split('-')start_port = int(ports[0]) #传递端口的范围end_port = int(ports[1])target_ip = gethostbyname(host) #传递目标IP地址opened_ports = [] #测试TCP端口连接for port in range(start_port, end_port): sock = socket(AF_INET, SOCK_STREAM) #IPv4,TCP连接 sock.settimeout(10) result = sock.connec_ex(target_ip, port) if result == 0: opened_ports.append(port)print('Opened poers:')for i in opened_ports: #输出端口开放结果 print(i) 然后用命令行的方式进行传参python wsw.py 127.0.0.1 100-200先用命令行进入wsw.py文件所在的文件，再执行上方代码。 AF_INET（又称 PF_INET）是 IPv4 网络协议的套接字类型，AF_INET6则是IPv6 的；而 AF_UNIX 则是 Unix 系统本地通信。选择 AF_INET 的目的就是使用 IPv4 进行通信。因为 IPv4 使用 32 位地址，相比IPv6 的 128 位来说，计算更快，便于用于局域网通信。而且 AF_INET 相比 AF_UNIX 更具通用性，因为 Windows 上有 AF_INET 而没有 AF_UNIX。 SOCK_STREAM：TCP是连接的，提供序列化的，可靠的，双向连接的字节流。支持带外数据传输 多线程端口扫描代码：123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-import sysimport threadingfrom socket import *print('dsjfhdj')def tcp_test(port): sock = socket(AF_INET, SOCK_STREAM) sock.settimeout(10) result = sock.connect_ex((target_ip, port)) if result == 0: lock.acquire() #加锁 print(\"Opened Port:\",port) lock.release() #释放锁if __name__=='__main__': host = sys.argv[1] portstrs = sys.argv[2].split('-') start_port = int(portstrs[0]) end_port = int(portstrs[1]) target_ip = gethostbyname(host) lock = threading.Lock() for port in range(start_port, end_port): threading.Thread(target = tcp_test, args = (port,)) ading.Thread(target = tcp_test, args = (port,)) 用来创建一个线程，该函数的第一个参数是一个线程中执行的函数，第二个参数必须是个元组，作为函数的输入，由于 tcp_test 函数只有一个参数，所以我们使用(port,)这种形式表示这个参数为元组。 实现TCP测试函数，需要注意print输出时候需要加锁，如果不加锁可能会出现多个输出混合在一起的错误状态，而锁需要在程序启动时创建，从而能让新建的线程共享这个锁， 注意当输出执行完后要释放锁lock。 端口扫描： http://www.yukaige.com/?p=160 创建服务端和客户端：代码详解：http://www.cnblogs.com/kellyseeme/p/5525026.html python socket编程详细介绍：http://blog.csdn.net/rebelqsp/article/details/22109925","categories":[],"tags":[]},{"title":"python中的模块","slug":"python中的模块","date":"2017-07-12T07:43:49.000Z","updated":"2017-07-13T07:01:30.542Z","comments":true,"path":"2017/07/12/python中的模块/","link":"","permalink":"http://yoursite.com/2017/07/12/python中的模块/","excerpt":"","text":"什么是模块，模块应该如何使用，见连接：http://www.cnblogs.com/dolphin0520/archive/2013/03/19/2969152.html from math import *是一次性引入math中所有的东西。 后续学到模块的新东西再继续添加","categories":[],"tags":[]},{"title":"Python 多线程","slug":"Python-多线程","date":"2017-07-11T05:50:01.000Z","updated":"2017-07-11T06:11:53.455Z","comments":true,"path":"2017/07/11/Python-多线程/","link":"","permalink":"http://yoursite.com/2017/07/11/Python-多线程/","excerpt":"通过看博客才明白什么是单线程和多线程，它们又是如何实现的等等问题，感觉这篇文章写的特别通俗易懂，记录一下。不过作者在文章中间出现了一些问题123456if __name__ == '__main__': for t in threads: t.setDaemon(True) t.start() t.join()print \"all over %s\" %ctime()","text":"通过看博客才明白什么是单线程和多线程，它们又是如何实现的等等问题，感觉这篇文章写的特别通俗易懂，记录一下。不过作者在文章中间出现了一些问题123456if __name__ == '__main__': for t in threads: t.setDaemon(True) t.start() t.join()print \"all over %s\" %ctime() 虽然解决了主线程的结束导致子线程的结束，但是如果前面的进程执行速度较慢，后面的进程执行速度快，但是只有最后一个进程设置了t.join（），会导致前面的进程被主线程终止。例如：把music中sleep（7）休眠时间改为大于5，此问题就暴露出来了，当t2线程结束之后，程序结束，但是t1进程还没有执行完毕，这明显与我们的初衷不符。所以建议改成12for t in threads： t.join() 便可避免此问题","categories":[],"tags":[]},{"title":"python strip()函数 以及 yield","slug":"python-strip-函数","date":"2017-07-09T09:37:19.000Z","updated":"2017-07-09T09:53:38.553Z","comments":true,"path":"2017/07/09/python-strip-函数/","link":"","permalink":"http://yoursite.com/2017/07/09/python-strip-函数/","excerpt":"python strip()函数声明：s为字符串，rm为要删除的字符序列 s.strip(rm) 删除s字符串中开头、结尾处，位于 rm删除序列的字符 s.lstrip(rm) 删除s字符串中开头处，位于 rm删除序列的字符","text":"python strip()函数声明：s为字符串，rm为要删除的字符序列 s.strip(rm) 删除s字符串中开头、结尾处，位于 rm删除序列的字符 s.lstrip(rm) 删除s字符串中开头处，位于 rm删除序列的字符s.rstrip(rm) 删除s字符串中结尾处，位于 rm删除序列的字符 注意： 当rm为空时，默认删除空白符（包括’\\n’, ‘\\r’, ‘\\t’, ‘ ‘) 2.这里的rm删除序列是只要边（开头或结尾）上的字符在删除序列内，就删除掉。 yield关于Python中的yield yield返回的是一个生成器 生成器最大的却别是它并不返回一个真正的数组yield 则是这个神奇的东西，和return一样，他返回东西，但他返回的是一个生成器生成器是通过一个或多个yield表达式构成的函数，每一个生成器都是一个迭代器（但是迭代器不一定是生成器）。如果一个函数包含yield关键字，这个函数就会变为一个生成器。生成器并不会一次返回所有结果，而是每次遇到yield关键字后返回相应结果，并保留函数当前的运行状态，等待下一次的调用。","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2017-07-09T09:03:52.102Z","updated":"2017-07-08T03:34:05.962Z","comments":true,"path":"2017/07/09/我的第一篇博客/","link":"","permalink":"http://yoursite.com/2017/07/09/我的第一篇博客/","excerpt":"日期: 2017-07-06 14:45:52正文:第一次用博客，写一篇文章记录一下。","text":"日期: 2017-07-06 14:45:52正文:第一次用博客，写一篇文章记录一下。 到今天，学习了以下的内容：1.Python3廖雪峰教程看到了函数式编程2.python的编码规范3.pythonic的典型实例4.学会了如何搭建自己的博客。5.Markdown的基本语法 虽然刚开始几天，但是收获可以说不少吧。Python虽然看了一遍，但是仅仅到达了解的地步，还没有完全掌握，这两天需要多练习Python代码。","categories":[],"tags":[]},{"title":"python 自学笔记","slug":"python-自学笔记","date":"2017-07-09T09:03:52.082Z","updated":"2017-07-12T06:34:16.741Z","comments":true,"path":"2017/07/09/python-自学笔记/","link":"","permalink":"http://yoursite.com/2017/07/09/python-自学笔记/","excerpt":"日期: 2017-07-07 17:17:42tags:对于单个字符的编码，Python 提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：","text":"日期: 2017-07-07 17:17:42tags:对于单个字符的编码，Python 提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符： &gt;&gt;&gt; ord(&apos;A&apos;) 65 &gt;&gt;&gt; ord(&apos;中&apos;) 20013 &gt;&gt;&gt; chr(66) &apos;B&apos; &gt;&gt;&gt; chr(25991) &apos;文&apos; 以 Unicode 表示的 str 通过 encode() 方法可以编码为指定的 bytes ，例如： &gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;) b&apos;ABC&apos; &gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;) b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87&apos; &gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;) &apos;ABC&apos; &gt;&gt;&gt; b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87&apos;.decode(&apos;utf-8&apos;) &apos;中文&apos; 计算字符串长度： &gt;&gt;&gt; len(&apos;ABC&apos;) 3 保留小数: &gt;&gt;&gt; &apos;%2d-%02d&apos; % (3, 1) &apos; 3-01&apos; &gt;&gt;&gt; &apos;%.2f&apos; % 3.1415926 &apos;3.14&apos; 有些时候，字符串里面的 % 是一个普通字符怎么办？这个时候就需要转义，用 %% 来表示一个 % ： &gt;&gt;&gt; &apos;growth rate: %d %%&apos; % 7 &apos;growth rate: 7 %&apos; list列表用法： &gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] &gt;&gt;&gt; classmates [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] &gt;&gt;&gt; classmates[0] &apos;Michael&apos; 获取最后一个元素： &gt;&gt;&gt; classmates[-1] &apos;Tracy&apos; 往 list 中追加元素到末尾： &gt;&gt;&gt; classmates.append(&apos;Adam&apos;) 把元素插入到指定的位置，比如索引号为 1 的位置： &gt;&gt;&gt; classmates.insert(1, &apos;Jack&apos;) 要删除指定位置的元素，用 pop(i) 方法，其中 i 是索引位置： &gt;&gt;&gt; classmates.pop(1) 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置： &gt;&gt;&gt; classmates[1] = &apos;Sarah&apos; Python 的循环有两种，一种是 for...in 循环，依次把 list 或 tuple 中的每个元素迭代出来，看例子： names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] for name in names: print(name) 执行这段代码，会依次打印 names 的每一个元素： Michael, Bob, Tracy sum = 0 for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: sum = sum + x print(sum) sum = 0 for x in range(101): sum = sum + x print(sum) 第二种循环是 while 循环，只要条件满足，就不断循环，条件不满足时退出循环。 sum = 0 n = 99 while n &gt; 0: sum = sum + n n = n - 2 print(sum) 重复元素在 set 中自动被过滤： &gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3]) &gt;&gt;&gt; s {1, 2, 3} &gt;&gt;&gt; s.add(4) &gt;&gt;&gt; s {1, 2, 3, 4} 通过 remove(key) 方法可以删除元素： &gt;&gt;&gt; s.remove(4) &gt;&gt;&gt; s {1, 2, 3} set 可以看成数学意义上的无序和无重复元素的集合，因此，两个 set 可以做数学意义上的交集、并集等操作： &gt;&gt;&gt; s1 = set([1, 2, 3]) &gt;&gt;&gt; s2 = set([2, 3, 4]) &gt;&gt;&gt; s1 &amp; s2 {2, 3} &gt;&gt;&gt; s1 | s2 {1, 2, 3, 4} 而对于不可变对象，比如 str，对 str 进行操作呢： &gt;&gt;&gt; a = &apos;abc&apos; &gt;&gt;&gt; a.replace(&apos;a&apos;, &apos;A&apos;) &apos;Abc&apos; &gt;&gt;&gt; a &apos;abc&apos; &gt;&gt;&gt; max(2, 3, 1, -5) 3 &gt;&gt;&gt; int(&apos;123&apos;) 123 &gt;&gt;&gt; int(12.34) 12 math包里含有数学运算有：三角函数：cos,sin。。开平方sqrt() &gt;&gt;&gt; import math &gt;&gt;&gt; math.sqrt(2) 1.4142135623730951 def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 对于这个修改后的 power(x, n) 函数，可以计算任意 n 次方： &gt;&gt;&gt; power(5, 2) 25 &gt;&gt;&gt; power(5, 3) 125 def enroll(name, gender, age=6, city=&apos;Beijing&apos;): print(&apos;name:&apos;, name) print(&apos;gender:&apos;, gender) print(&apos;age:&apos;, age) print(&apos;city:&apos;, city) 这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参 数： &gt;&gt;&gt; enroll(&apos;Sarah&apos;, &apos;F&apos;) name: Sarah gender: F age: 6 city: Beijing def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum &gt;&gt;&gt; calc((1, 3, 5, 7)) 定义可变参数和定义一个 list 或 tuple 参数相比，仅仅在参数前面加了一个 * 号。 def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum &gt;&gt;&gt; calc(1, 2) 5 &gt;&gt;&gt; nums = [1, 2, 3] &gt;&gt;&gt; calc(*nums) 14 def person(name, age, **kw): print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw) &gt;&gt;&gt; person(&apos;Michael&apos;, 30) name: Michael age: 30 other: {} &gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;) name: Bob age: 35 other: {&apos;city&apos;: &apos;Beijing&apos;} 递归函数： def fact(n): if n==1: return 1 return n * fact(n - 1) &gt;&gt;&gt; fact(5) 120 函数的切片： &gt;&gt;&gt; L[0:3] [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] L[0:3] 表示，从索引 0 开始取，直到索引 3 为止，但不包括索引 3 。 &gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2) &gt;&gt;&gt; &apos;ABCDEFG&apos;[:3] &apos;ABC&apos; 前 10 个数，每两个取一个： &gt;&gt;&gt; L[:10:2] [0, 2, 4, 6, 8] Python异常处理 try…except…我们把可能发生错误的语句放在try模块里，用except来处理异常。except可以处理一个专门的异常，也可以处理一组圆括号中的异常，如果except后没有指定异常，则默认处理所有的异常。每一个try，都必须至少有一个except。当try语句块出现错误，便跳出try程序块，执行excepttry ….except…else 语句，当没有异常发生时，try和else中的语句将会被执行，而except不执行。12345678910a=10b=0try: c = b/ a print cexcept (IOError ,ZeroDivisionError),x: print xelse: print \"no error\"print \"done\" python if name == ‘main‘解析换句通俗的话讲，当你在当前文件运行一个文件时，__name__==__main__，则其后的代码会正常执行，但是当你在另一个文件import这个文件的时候，此时__name__！=__main__，则以下的代码将不会执行。至于他的作用，我简单的理解就是加入if __name__ == &quot;__main__&quot;后，它后面的代码在其它地方引用时，就不执行，从而方便了代码的重用。示例：add.py如下：1234567def add(x,y): return x+yif __name__ == \"__main__\"： print add(3,4) 当我在其它地方引用这个add.py时，就不执行print。","categories":[],"tags":[]},{"title":"python中lambda表达式学习","slug":"lambda表达式学习","date":"2017-07-09T09:03:52.033Z","updated":"2017-07-07T11:20:16.697Z","comments":true,"path":"2017/07/09/lambda表达式学习/","link":"","permalink":"http://yoursite.com/2017/07/09/lambda表达式学习/","excerpt":"date: 2017-07-07 18:09:14 tags:lambda只是一个表达式，函数体比def简单很多。","text":"date: 2017-07-07 18:09:14 tags:lambda只是一个表达式，函数体比def简单很多。lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。 lambda表达式是起到一个函数速写的作用。允许在代码内嵌入一个函数的定义。 如下例子：定义了一个lambda表达式，求三个数的和。 再看一个例子：用lambda表达式求n的阶乘。 lambda表达式也可以用在def函数中。如下例子： 这里定义了一个action函数，返回了一个lambda表达式。其中lambda表达式获取到了上层def作用域的变量名x的值。a是action函数的返回值，a(22)，即是调用了action返回的lambda表达式。这里也可以把def直接写成lambda形式。如下 看教程看到这一题答案发现原来有更简单的写法，用了lambda,当时不知道用法，然后百度后才明白 from functools import reduce def prod(L): return reduce(lambda x,y: x*y,L) print(&apos;3 * 5 * 7 * 9 =&apos;, prod([3, 5, 7, 9]))","categories":[],"tags":[]},{"title":"python的典型实例","slug":"python的典型实例","date":"2017-07-09T09:03:52.023Z","updated":"2017-07-09T09:51:25.030Z","comments":true,"path":"2017/07/09/python的典型实例/","link":"","permalink":"http://yoursite.com/2017/07/09/python的典型实例/","excerpt":"date: 2017-07-07 18:21:52 tags:nonlocal关键字用来在函数或其他作用域中使用外层(非全局)变量。","text":"date: 2017-07-07 18:21:52 tags:nonlocal关键字用来在函数或其他作用域中使用外层(非全局)变量。 不知道字符串转大写是upper()，转小写是lower() 忘记字符串也可以切片了 字符串的连接原来可以用加号+ 123456def normalize(name): return name[0].upper()+name[1:].lower()L1 = ['adam', 'LISA', 'barT']L2 = list(map(normalize, L1))print(L2) name[0].upper() 是首字母大写name[1:].lower() 从第二个字母开始全都小写 字符串转数的算法已经在示例中已经有了，也很好理解。转成浮点数的难点在于小数点两遍的数字处理方法不一样。我想肯定需要一个判断句，判断在小数点的左右，而采用不同的方法。同时，还要一个参数来记住小数点的位置。最终，又是参考各位大神，又是参照作者的答案。大概是懂了。 作者的答案:1234567891011121314151617181920212223242526272829303132from functools import reduceCHAR_TO_FLOAT = &#123; '0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '.': -1 &#125;def str2float(s): nums = map(lambda ch: CHAR_TO_FLOAT[ch], s) point = 0def to_float(f, n): nonlocal point if n == -1: point = 1 return f if point == 0: return f * 10 + n else: point = point * 10 return f + n / point return reduce(to_float, nums, 0.0) print(str2float('0')) print(str2float('123.456')) print(str2float('123.45600')) print(str2float('0.1234')) 由于to_float传入的数据都是数而不是字符，因此CHAR_TO_FLOAT里面定义.为0-9以外的数，加以区分。if n == -1:用来判断是否已经到小数点的位置，如果到了则改变point的值，point可以说是记录了当前小数点的位置，默认为0。然后根据point值来判断小数点的位置，以确定使用哪个转换算法。return reduce(to_float,nums,0.0)中有一项是0.0，是为了转换整数字符为浮点数。如果不添加0.0，则CHAR_TO_FLOAT里的value都要改成浮点数的形式，key值不用改，小数点对应的数值也可以不改。 筛选出字符串类型并展示：123456789101112L1=['hello','world',18,'apple',None]L2=[]n=1for s in L1: if isinstance(s,str)==1: L2.append(s.lower()) else: print('the number of non str is %d ' %(n)) n=n+1 print(L2)L2=[s.lower() for s in L1 if isinstance(s,str)==1]print(L2) 斐波拉契数列12345678 def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b n = n + 1 return 'done'上面的函数可以输出斐波那契数列的前 N 个数：&gt;&gt;&gt; fib(6) 杨辉三角12345678910111213141516171819202122def triangles(): j = 0 L1 = [] L2 = [] S1 = 0 while j &lt; 10: s = 0 for i in L1: S1 = s + i s = i #記錄上個循環i的值 L2.append(S1) L2.append(1) yield L2 #生成器 返回L2 list 列表的值 L1 = L2[:] #將L1指向L2 變成上一次循環的list L2 = [] #L2保存的是當次循環的list 初始化她 j = j + 1n = 0for x in triangles(): print(x) n = n + 1 if n == 10: break 滤掉非回数回数是指从左向右读和从右向左读都是一样的数，例如 12321 ， 909 。请利用 filter() 滤掉非回数1234def i(n): return str(n) == str(n)[::-1]output = filter(i, range(1, 10000))print(list(output)) 把一个序列中的空字符串删掉1234def not_empty(s): return s and s.strip()list(filter(not_empty, ['A', '', 'B', None, 'C', ' ']))# 结果: ['A', 'B', 'C'] 删掉偶数，只保留奇数1234def is_odd(n): return n % 2 == 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))# 结果: [1, 5, 9, 15] 将一个16进制的数转换为十进制：123def int2(x, base=16): return int(x, base)print(int2('12345')) 排序假设我们用一组 tuple 表示学生名字和成绩：L = [(‘Bob’, 75), (‘Adam’, 92), (‘Bart’, 66), (‘Lisa’, 88)] 请用 sorted() 对上述列表分别按成绩从高到低排序：12345L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]def by_name(t): return t[1]L2 = sorted(L, key=by_name, reverse = True)print(L2)","categories":[],"tags":[]}]}